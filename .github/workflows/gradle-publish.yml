name: Blue-Green Deployment to EC2

on:
  push:
    branches: [ OSAEK-CI-CD-TEST ]
  pull_request:
    branches: [ OSAEK-CI-CD-TEST ]
  release:
    types: [created]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  EC2_HOST: ${{ secrets.EC2_HOST }}
  AWS_REGION: ${{ secrets.AWS_REGION }}
  S3_BUCKET: ${{ secrets.S3_BUCKET_NAME }}
  KAKAO_CLIENT_ID: ${{ secrets.KAKAO_CLIENT_ID }}
  KAKAO_CLIENT_SECRET: ${{ secrets.KAKAO_CLIENT_SECRET }}
  JWT_SECRET: ${{ secrets.JWT_SECRET }}
  DB_HOST: ${{ secrets.DB_HOST }}
  DB_NAME: ${{ secrets.DB_NAME }}
  DB_USERNAME: ${{ secrets.DB_USERNAME }}
  DB_PASSWORD: ${{ secrets.DB_PASSWORD }}

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up JDK 21
      uses: actions/setup-java@v4
      with:
        java-version: '21'
        distribution: 'temurin'
        
    - name: Cache Gradle packages
      uses: actions/cache@v4
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
        restore-keys: |
          ${{ runner.os }}-gradle-
          
    - name: Grant execute permission for gradlew
      run: chmod +x gradlew

    # ÌÖåÏä§Ìä∏Îäî ÏóÜÏù¥ ÏùºÎã® Î∞∞Ìè¨ ÎêòÎäîÏßÄ ÌôïÏù∏ÌïòÍ∏∞
    - name: Build with Gradle
      run: ./gradlew build -x test  
    # - name: Run tests
    #   run: ./gradlew test
      
    # - name: Generate test report
    #   uses: dorny/test-reporter@v1
    #   if: success() || failure()
    #   with:
    #     name: Gradle Tests
    #     path: build/test-results/test/*.xml
    #     reporter: java-junit
        
    # - name: Upload test results
    #   uses: actions/upload-artifact@v4
    #   if: always()
    #   with:
    #     name: test-results-${{ github.sha }}
    #     path: build/test-results/test/*.xml
    #     retention-days: 7

  build-and-publish:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/OSAEK-CI-CD-TEST' || github.event_name == 'release'
    
    permissions:
      contents: read
      packages: write
      
    outputs:
      jar-name: ${{ steps.jar-info.outputs.jar-name }}
      jar-version: ${{ steps.jar-info.outputs.jar-version }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up JDK 21
      uses: actions/setup-java@v4
      with:
        java-version: '21'
        distribution: 'temurin'
        
    - name: Cache Gradle packages
      uses: actions/cache@v4
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
        restore-keys: |
          ${{ runner.os }}-gradle-
          
    - name: Grant execute permission for gradlew
      run: chmod +x gradlew
      
    - name: Build Spring Boot JAR
      run: ./gradlew bootJar
      
    - name: Extract JAR information
      id: jar-info
      run: |
        JAR_FILE=$(ls build/libs/*.jar | head -n 1)
        JAR_NAME=$(basename $JAR_FILE)
        JAR_SIZE=$(du -h "$JAR_FILE" | cut -f1)
        VERSION=$(echo $JAR_NAME | grep -o '[0-9]\+\.[0-9]\+\.[0-9]\+' || echo "0.0.1-SNAPSHOT")
        
        echo "jar-name=$JAR_NAME" >> $GITHUB_OUTPUT
        echo "jar-version=$VERSION" >> $GITHUB_OUTPUT
        echo "üì¶ Built JAR: $JAR_NAME ($JAR_SIZE)"
        
    - name: Upload JAR to GitHub Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: spring-boot-jar-${{ github.sha }}
        path: build/libs/*.jar
        retention-days: 30
  
    # GradleÏóêÏÑú Ïù¥ Î∞©ÏãùÏúºÎ°ú Î∞∞Ìè¨Î•º ÌïòÎ†§Î©¥ maven ÌîåÎü¨Í∑∏Ïù∏Ïù¥ ÌïÑÏöîÌïòÎã§ 
    # - name: Publish JAR to GitHub Packages
    #   run: ./gradlew publish
    #   env:
    #     USERNAME: ${{ github.actor }}
    #     TOKEN: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Extract metadata for Docker
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=semver,pattern={{version}}
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable=${{ github.ref == 'refs/heads/OSAEK-CI-CD-TEST' }}
          
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        platforms: linux/amd64
        cache-from: type=gha
        cache-to: type=gha,mode=max

  create-release-assets:
    needs: build-and-publish
    runs-on: ubuntu-latest
    if: github.event_name == 'release'
    
    permissions:
      contents: write
      
    steps:
    - name: Download JAR artifact
      uses: actions/download-artifact@v4
      with:
        name: spring-boot-jar-${{ github.sha }}
        path: ./artifacts
        
    - name: Create deployment package
      run: |
        mkdir -p deployment-package
        cp artifacts/*.jar deployment-package/
        
        # Î∞∞Ìè¨ Ïä§ÌÅ¨Î¶ΩÌä∏ ÏÉùÏÑ±
        cat > deployment-package/deploy.sh << 'EOF'
        #!/bin/bash
        
        JAR_FILE=$(ls *.jar | head -n 1)
        echo "üöÄ Deploying $JAR_FILE"
        
        # Blue-Green Î∞∞Ìè¨ Î°úÏßÅ (Í∞ÑÎã® Î≤ÑÏ†Ñ)
        if pgrep -f "java.*jar" > /dev/null; then
            echo "üîÑ Stopping existing application..."
            pkill -f "java.*jar"
            sleep 5
        fi
        
        echo "üü¢ Starting new application..."
        nohup java -jar $JAR_FILE > app.log 2>&1 &
        echo "‚úÖ Application started!"
        EOF
        
        chmod +x deployment-package/deploy.sh
        
        # README ÏÉùÏÑ±
        cat > deployment-package/README.md << 'EOF'
        # Deployment Package
        
        ## Files:
        - `*.jar`: Spring Boot application
        - `deploy.sh`: Simple deployment script
        
        ## Usage:
        ```bash
        ./deploy.sh
        ```
        EOF
        
        # ÏïïÏ∂ï
        tar -czf spring-boot-deployment-${{ github.ref_name }}.tar.gz -C deployment-package .
        
    - name: Upload Release Assets
      uses: softprops/action-gh-release@v1
      with:
        files: |
          spring-boot-deployment-${{ github.ref_name }}.tar.gz
          artifacts/*.jar
        generate_release_notes: true
        body: |
          ## üöÄ Release ${{ github.ref_name }}
          
          ### üì¶ Assets:
          - **JAR**: ${{ needs.build-and-publish.outputs.jar-name }}
          - **Docker**: `${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.ref_name }}`
          - **Deployment Package**: Complete deployment bundle
          
          ### üê≥ Docker Run:
          ```bash
          docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.ref_name }}
          docker run -p 8080:8080 ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.ref_name }}
          ```
          
          ### üì• Download & Deploy:
          ```bash
          # Download deployment package
          wget https://github.com/${{ github.repository }}/releases/download/${{ github.ref_name }}/spring-boot-deployment-${{ github.ref_name }}.tar.gz
          
          # Extract and deploy
          tar -xzf spring-boot-deployment-${{ github.ref_name }}.tar.gz
          ./deploy.sh
          ```

  deploy-blue-green:
    needs: build-and-publish
    runs-on: ubuntu-latest
    
    steps:
    - name: Setup SSH key
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key.pem
        chmod 600 ~/.ssh/deploy_key.pem
        ssh-keyscan -H ${{ env.EC2_HOST }} >> ~/.ssh/known_hosts
        
    - name: Deploy with Blue-Green strategy
      run: |
        ssh -i ~/.ssh/deploy_key.pem ubuntu@${{ env.EC2_HOST }} << 'EOF'
          set -e
          
          # GitHub Container Registry Î°úÍ∑∏Ïù∏ (ÌïÑÏöîÏãú)
          echo ${{ secrets.GITHUB_TOKEN }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin
          
          # ÌòÑÏû¨ ÌôúÏÑ± Ïª®ÌÖåÏù¥ÎÑà ÌôïÏù∏
          if docker ps | grep -q "app-blue.*Up"; then
            ACTIVE_COLOR="blue"
            INACTIVE_COLOR="green"
            ACTIVE_PORT="8080"
            INACTIVE_PORT="8081"
          else
            ACTIVE_COLOR="green"
            INACTIVE_COLOR="blue"
            ACTIVE_PORT="8081"
            INACTIVE_PORT="8080"
          fi
          
          echo "üéØ Current active: $ACTIVE_COLOR ($ACTIVE_PORT)"
          echo "üöÄ Deploying to: $INACTIVE_COLOR ($INACTIVE_PORT)"
          
          # ÏÉà Ïù¥ÎØ∏ÏßÄ pull
          docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
          
          # ÎπÑÌôúÏÑ± Ïª®ÌÖåÏù¥ÎÑà Ï§ëÏßÄ Î∞è Ï†úÍ±∞
          docker stop app-$INACTIVE_COLOR || true
          docker rm app-$INACTIVE_COLOR || true
          
          # ÏÉà Ïª®ÌÖåÏù¥ÎÑà ÏãúÏûë (ÎπÑÌôúÏÑ± Ìè¨Ìä∏Ïóê)
          docker run -d \
            --name app-$INACTIVE_COLOR \
            -p $INACTIVE_PORT:8080 \
            -e SPRING_PROFILES_ACTIVE=dev \
            -e SERVER_COLOR=$INACTIVE_COLOR \
            -e AWS_REGION=${{ env.AWS_REGION }} \
            -e S3_BUCKET=${{ env.S3_BUCKET }} \
            -e KAKAO_CLIENT_ID=${{ env.KAKAO_CLIENT_ID }} \
            -e KAKAO_CLIENT_SECRET=${{ env.KAKAO_CLIENT_SECRET }} \
            -e JWT_SECRET=${{ env.JWT_SECRET }} \
            -e DB_HOST=${{ env.DB_HOST }} \
            -e DB_NAME=${{ env.DB_NAME }} \
            -e DB_USERNAME=${{ env.DB_USERNAME }} \
            -e DB_PASSWORD=${{ env.DB_PASSWORD }} \
            -e SERVER_URL=http://${{ env.EC2_HOST }} \
            --network docker_app-network \
            --restart unless-stopped \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
          
          # Ìó¨Ïä§Ï≤¥ÌÅ¨ ÎåÄÍ∏∞
          echo "‚è≥ Waiting for health check..."
          for i in {1..30}; do
            if curl -f http://localhost:$INACTIVE_PORT/actuator/health > /dev/null 2>&1; then
              echo "‚úÖ Health check passed!"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "‚ùå Health check failed!"
              exit 1
            fi
            sleep 5
          done
          
          # Nginx ÏÑ§Ï†ï ÏóÖÎç∞Ïù¥Ìä∏ (Ìè¨Ìä∏ Ï†ÑÌôò) - Docker Î≤ÑÏ†Ñ
          docker exec nginx-proxy sed -i "s/server host\.docker\.internal:[0-9]*;/server host.docker.internal:$INACTIVE_PORT;/g" /etc/nginx/conf.d/app.conf
          docker exec nginx-proxy nginx -t && docker exec nginx-proxy nginx -s reload
          
          # Ïù¥Ï†Ñ ÌôúÏÑ± Ïª®ÌÖåÏù¥ÎÑàÎ•º Ïû†Ïãú Ïú†ÏßÄ (Î°§Î∞±Ïö©)
          echo "üîÑ Traffic switched to $INACTIVE_COLOR"
          echo "üí§ Previous $ACTIVE_COLOR container kept for rollback"
          
          # 30Ï¥à ÌõÑ Ïù¥Ï†Ñ Ïª®ÌÖåÏù¥ÎÑà Ï†ïÎ¶¨ (Î∞±Í∑∏ÎùºÏö¥Îìú)
          (sleep 30 && docker stop app-$ACTIVE_COLOR && docker rm app-$ACTIVE_COLOR) &
        EOF
        
    - name: Verify deployment
      run: |
        echo "üîç Verifying deployment..."
        sleep 10  # Î∞∞Ìè¨ ÏïàÏ†ïÌôî ÎåÄÍ∏∞
        
        if curl -f http://${{ env.EC2_HOST }}/actuator/health; then
          echo "‚úÖ Deployment successful!"
          
          # Î∞∞Ìè¨ Ï†ïÎ≥¥ Ï∂úÎ†•
          echo "üì± Application URL: http://${{ env.EC2_HOST }}"
          echo "üê≥ Docker Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest"
          echo "üì¶ JAR: ${{ needs.build-and-publish.outputs.jar-name }}"
        else
          echo "‚ùå Deployment verification failed!"
          exit 1
        fi

  deployment-notification:
    needs: [build-and-publish, deploy-blue-green]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
    - name: Create deployment summary
      run: |
        if [ "${{ needs.deploy-blue-green.result }}" = "success" ]; then
          echo "## üéâ Deployment Successful!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üì± Application Info:" >> $GITHUB_STEP_SUMMARY
          echo "- **URL**: http://${{ env.EC2_HOST }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: Test (OSAEK-CI-CD-TEST)" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üê≥ Docker Info:" >> $GITHUB_STEP_SUMMARY
          echo "- **Registry**: GitHub Container Registry" >> $GITHUB_STEP_SUMMARY
          echo "- **Image**: \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üì¶ Artifacts:" >> $GITHUB_STEP_SUMMARY
          echo "- **JAR**: Available in GitHub Packages" >> $GITHUB_STEP_SUMMARY
          echo "- **Test Results**: Available in Actions artifacts" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ github.event_name }}" = "release" ]; then
            echo "- **Release Assets**: Available in GitHub Releases" >> $GITHUB_STEP_SUMMARY
          fi
        else
          echo "## ‚ùå Deployment Failed!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Please check the deployment logs and try again." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üîÑ Rollback Instructions:" >> $GITHUB_STEP_SUMMARY
          echo "```bash" >> $GITHUB_STEP_SUMMARY
          echo "# SSH to EC2 and run rollback script" >> $GITHUB_STEP_SUMMARY
          echo "ssh -i your-key.pem ec2-user@${{ env.EC2_HOST }}" >> $GITHUB_STEP_SUMMARY
          echo "~/rollback.sh" >> $GITHUB_STEP_SUMMARY
          echo "```" >> $GITHUB_STEP_SUMMARY
        fi
        
    - name: Comment on PR (if applicable)
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const deployResult = "${{ needs.deploy-blue-green.result }}";
          const isSuccess = deployResult === "success";
          const statusIcon = isSuccess ? "‚úÖ" : "‚ùå";
          const statusText = isSuccess ? "Success" : "Failed";
          const appUrl = "http://${{ env.EC2_HOST }}";
          const dockerImage = "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest";
          const commitSha = "${{ github.sha }}";
          
          let message;
          if (isSuccess) {
            message = "The application has been successfully deployed and is ready for testing!";
          } else {
            message = "Deployment failed. Please check the logs and try again.";
          }
          
          const commentBody = [
            "## üöÄ Deployment Status: " + statusIcon + " " + statusText,
            "",
            "**Application URL**: " + appUrl,
            "**Docker Image**: `" + dockerImage + "`", 
            "**Commit**: " + commitSha,
            "",
            message
          ].join("\n");
          
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: commentBody
          });

  discord-notification:
    needs: [deploy-blue-green]
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: Send Discord Notification
        run: |
          STATUS="${{ needs.deploy-blue-green.result }}"
          COMMIT_URL="https://github.com/${{ github.repository }}/commit/${{ github.sha }}"
          APP_URL="http://${{ env.EC2_HOST }}"
          IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest"
          BRANCH="${{ github.ref_name }}"
          WEBHOOK_URL="${{ secrets.DISCORD_WEBHOOK_URL }}"
          MESSAGE=""

          if [ "$STATUS" = "success" ]; then
            MESSAGE="‚úÖ **Deployment Successful!**
            - **Branch**: \`$BRANCH\`
            - **App**: <$APP_URL>
            - **Docker**: \`$IMAGE\`
            - **Commit**: <$COMMIT_URL>"
          else
            MESSAGE="‚ùå **Deployment Failed!**
            - **Branch**: \`$BRANCH\`
            - **Commit**: <$COMMIT_URL>
            Please check the logs."
          fi

          curl -X POST -H "Content-Type: application/json" \
            -d "{\"content\": \"$MESSAGE\"}" \
            $WEBHOOK_URL
